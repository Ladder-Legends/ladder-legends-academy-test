import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { deviceCodeStore, DeviceCode } from '../device-code-store';
import fs from 'fs';
import os from 'os';
import path from 'path';

// Mock Vercel KV
jest.mock('@vercel/kv', () => ({
  kv: {
    get: jest.fn(),
    set: jest.fn(),
    del: jest.fn(),
  },
}));

describe('DeviceCodeStore', () => {
  const mockCode: DeviceCode = {
    device_code: 'test-device-code-123',
    user_code: 'TEST-CODE',
    status: 'pending',
    created_at: new Date('2025-01-01T00:00:00Z'),
    expires_at: new Date('2025-01-01T00:15:00Z'),
  };

  const authorizedCode: DeviceCode = {
    ...mockCode,
    status: 'authorized',
    user_id: 'user-123',
    authorized_at: new Date('2025-01-01T00:05:00Z'),
    user_data: {
      id: 'user-123',
      username: 'TestUser',
      avatar_url: 'https://example.com/avatar.png',
    },
  };

  describe('File-based storage (no KV)', () => {
    let storePath: string;

    beforeEach(() => {
      // Clear environment to force file-based storage
      delete process.env.KV_REST_API_URL;
      const tmpDir = os.tmpdir();
      storePath = path.join(tmpDir, 'ladder-legends-device-codes.json');

      // Clean up any existing test file
      if (fs.existsSync(storePath)) {
        fs.unlinkSync(storePath);
      }
    });

    afterEach(() => {
      // Clean up
      if (fs.existsSync(storePath)) {
        fs.unlinkSync(storePath);
      }
    });

    it('should save and retrieve a device code', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);
      const retrieved = await deviceCodeStore.get(mockCode.device_code);

      expect(retrieved).toBeDefined();
      expect(retrieved?.device_code).toBe(mockCode.device_code);
      expect(retrieved?.user_code).toBe(mockCode.user_code);
      expect(retrieved?.status).toBe('pending');
    });

    it('should save code by both device_code and user_code', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);

      const byDeviceCode = await deviceCodeStore.get(mockCode.device_code);
      const byUserCode = await deviceCodeStore.get(mockCode.user_code);

      expect(byDeviceCode).toBeDefined();
      expect(byUserCode).toBeDefined();
      expect(byDeviceCode?.device_code).toBe(byUserCode?.device_code);
    });

    it('should return undefined for non-existent code', async () => {
      const result = await deviceCodeStore.get('non-existent');
      expect(result).toBeUndefined();
    });

    it('should delete expired codes', async () => {
      const expiredCode = {
        ...mockCode,
        expires_at: new Date('2020-01-01T00:00:00Z'), // Past date
      };

      await deviceCodeStore.set(expiredCode.device_code, expiredCode);
      const result = await deviceCodeStore.get(expiredCode.device_code);

      expect(result).toBeUndefined();
    });

    it('should update code status', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);
      await deviceCodeStore.set(authorizedCode.device_code, authorizedCode);

      const updated = await deviceCodeStore.get(authorizedCode.device_code);
      expect(updated?.status).toBe('authorized');
      expect(updated?.user_id).toBe('user-123');
      expect(updated?.user_data?.username).toBe('TestUser');
    });

    it('should delete code by device_code', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);
      await deviceCodeStore.delete(mockCode.device_code);

      const result = await deviceCodeStore.get(mockCode.device_code);
      expect(result).toBeUndefined();
    });

    it('should delete code by both device_code and user_code', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);
      await deviceCodeStore.delete(mockCode.device_code, mockCode.user_code);

      const byDeviceCode = await deviceCodeStore.get(mockCode.device_code);
      const byUserCode = await deviceCodeStore.get(mockCode.user_code);

      expect(byDeviceCode).toBeUndefined();
      expect(byUserCode).toBeUndefined();
    });

    it('should check if code exists', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);

      const exists = await deviceCodeStore.has(mockCode.device_code);
      const notExists = await deviceCodeStore.has('non-existent');

      expect(exists).toBe(true);
      expect(notExists).toBe(false);
    });

    it('should preserve Date objects when storing and retrieving', async () => {
      await deviceCodeStore.set(mockCode.device_code, mockCode);
      const retrieved = await deviceCodeStore.get(mockCode.device_code);

      expect(retrieved?.created_at).toBeInstanceOf(Date);
      expect(retrieved?.expires_at).toBeInstanceOf(Date);
      expect(retrieved?.created_at.toISOString()).toBe(mockCode.created_at.toISOString());
      expect(retrieved?.expires_at.toISOString()).toBe(mockCode.expires_at.toISOString());
    });

    it('should handle authorized_at date correctly', async () => {
      await deviceCodeStore.set(authorizedCode.device_code, authorizedCode);
      const retrieved = await deviceCodeStore.get(authorizedCode.device_code);

      expect(retrieved?.authorized_at).toBeInstanceOf(Date);
      expect(retrieved?.authorized_at?.toISOString()).toBe(authorizedCode.authorized_at?.toISOString());
    });

    it('should handle multiple codes in the same file', async () => {
      const code1 = { ...mockCode, device_code: 'code-1', user_code: 'CODE-1' };
      const code2 = { ...mockCode, device_code: 'code-2', user_code: 'CODE-2' };

      await deviceCodeStore.set(code1.device_code, code1);
      await deviceCodeStore.set(code2.device_code, code2);

      const retrieved1 = await deviceCodeStore.get(code1.device_code);
      const retrieved2 = await deviceCodeStore.get(code2.device_code);

      expect(retrieved1?.user_code).toBe('CODE-1');
      expect(retrieved2?.user_code).toBe('CODE-2');
    });

    it('should handle file system errors gracefully', async () => {
      // Try to get from a non-existent store
      const result = await deviceCodeStore.get('any-code');

      // Should not throw, just return undefined
      expect(result).toBeUndefined();
    });
  });

  describe('Date parsing', () => {
    it('should convert string dates to Date objects', async () => {
      // Simulate what KV would return (dates as strings)
      const codeWithStringDates = {
        ...mockCode,
        created_at: '2025-01-01T00:00:00Z' as any,
        expires_at: '2025-01-01T00:15:00Z' as any,
      };

      await deviceCodeStore.set(mockCode.device_code, codeWithStringDates);
      const retrieved = await deviceCodeStore.get(mockCode.device_code);

      // Should be converted back to Date objects
      expect(retrieved?.created_at).toBeInstanceOf(Date);
      expect(retrieved?.expires_at).toBeInstanceOf(Date);
    });

    it('should handle authorized_at as string', async () => {
      const codeWithStringDate = {
        ...authorizedCode,
        authorized_at: '2025-01-01T00:05:00Z' as any,
      };

      await deviceCodeStore.set(authorizedCode.device_code, codeWithStringDate);
      const retrieved = await deviceCodeStore.get(authorizedCode.device_code);

      expect(retrieved?.authorized_at).toBeInstanceOf(Date);
    });
  });

  describe('TTL calculation', () => {
    it('should calculate correct TTL for future expiration', async () => {
      const futureDate = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes from now
      const code = {
        ...mockCode,
        expires_at: futureDate,
      };

      // This should not throw
      await deviceCodeStore.set(code.device_code, code);

      const retrieved = await deviceCodeStore.get(code.device_code);
      expect(retrieved).toBeDefined();
    });

    it('should handle expired codes', async () => {
      const pastDate = new Date(Date.now() - 15 * 60 * 1000); // 15 minutes ago
      const expiredCode = {
        ...mockCode,
        expires_at: pastDate,
      };

      await deviceCodeStore.set(expiredCode.device_code, expiredCode);
      const retrieved = await deviceCodeStore.get(expiredCode.device_code);

      // Expired codes should be deleted
      expect(retrieved).toBeUndefined();
    });
  });

  describe('Status values', () => {
    it('should handle all status values', async () => {
      const statuses: Array<DeviceCode['status']> = ['pending', 'authorized', 'denied', 'expired'];

      for (const status of statuses) {
        const code = { ...mockCode, device_code: `code-${status}`, status };
        await deviceCodeStore.set(code.device_code, code);
        const retrieved = await deviceCodeStore.get(code.device_code);
        expect(retrieved?.status).toBe(status);
      }
    });
  });

  describe('Error handling', () => {
    it('should not throw on delete of non-existent code', async () => {
      // Should not throw
      await expect(deviceCodeStore.delete('non-existent')).resolves.not.toThrow();
    });

    it('should not throw on has() for non-existent code', async () => {
      const result = await deviceCodeStore.has('non-existent');
      expect(result).toBe(false);
    });
  });
});
